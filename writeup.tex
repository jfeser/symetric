\documentclass[review]{acmart}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{semantic}        %% For PL semantics
\usepackage{stmaryrd}
\usepackage{mathbbol}

\author{John Feser}
\title{Abstract bottom-up enumeration}

\newcommand{\abs}[1]{\ensuremath{\widetilde{#1}}}
\renewcommand{\eval}[1]{\ensuremath{\mathcal{E}\llbracket#1\rrbracket}}
\newcommand{\aeval}[1]{\ensuremath{\abs{\mathcal{E}}\llbracket#1\rrbracket}}

\begin{document}

\section{Algorithm}
\subsection{Bottom-up Enumeration}

In this section we formalize a bottom-up enumeration algorithm for an untyped
DSL with binary operators. The algorithm generates a set of states $\mathcal{V}
= \bigcup_i V_i$, where $V_i$ contains states that are reachable by a program of
size at most $i$. It also generates a finite relation $R : State \times Operator
\times State \times State$. If $(\sigma, op, \delta, \delta') \in R$, then
$\eval{op(\delta, \delta')} = \sigma$ and $\sigma, \delta, \delta' \in
\mathcal{V}$. Once the target state is reached during enumeration, $R$ is used
to construct a program that produces the target state from the input states.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{BottomUp}{$O, Init, Goal$}
    \State $R <- \emptyset, V_0 <- \emptyset, V_1 <- Init$
    \For{$i \in [2, \dots]$}
    \If {$Goal \in \mathcal{V}$}
    \State \Return $\Call{Reconstruct}{R, Init, Goal}$
    \EndIf
    \State $V_i, R <- \Call{Fill}{O, \mathcal{V}, i}$
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{Reconstruct}{$R, Init, \sigma$}
    \If {$\sigma \in Init$}
    \State \Return $\sigma$
    \EndIf
    \State Choose $(\sigma, op, \sigma_l, \sigma_r) \in R$
    \State \Return $op(\Call{Reconstruct}{R, Init, \sigma_l},
    \Call{Reconstruct}{R, Init, \sigma_r})$
    \EndFunction
  \end{algorithmic}

  \begin{algorithmic}[1]
    \Function{Fill}{$O, \mathcal{V}, i$}
    \State Let $\Delta = V_{i - 1} \setminus V_{i - 2}$
    \State $V_i <- V_{i - 1}$
    \For{$op \in O, v \in V_{i - 1}, \delta \in \Delta$}
    \State Let $t = op(v, \delta)$ and $t' = op(\delta, v)$
    \State Let $\sigma = \eval{t}$ and $\sigma' = \eval{t'}$
    \State $V_i <- V_i \cup \{\sigma, \sigma'\}$
    \State $R <- R \cup \{(\sigma, op, v, \delta), (\sigma, op, \delta, v)\}$
    \EndFor
    \State \Return $(V_i, R)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{theorem}[Soundness]
  If $\Call{BottomUp}{O, Init, Goal} = t$, then $\eval{t} = Goal$.
\end{theorem}

\begin{theorem}[Completeness]
  Let $S = \{t | \eval{t} = Goal\}$. If $S \neq \emptyset$ then
  $\Call{BottomUp}{O, Init, Goal} = t$ where $t \in S$.
\end{theorem}

\subsection{Abstract Bottom-up Enumeration}

In this section we introduce a generalization of the bottom-up enumeration
algorithm that uses abstract instead of concrete states. This introduces an
additional complication: the precision loss caused by the abstraction means that
the goal states that the algorithm reaches may be spurious. The abstraction must
be incrementally refined to eliminate these spurious goal states.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{AbstractBottomUp}{$O, Init, Goal$}
    \State $\abs{R} <- \emptyset, \abs{V_0} <- \emptyset, \abs{V_1} <- \{\top\}$
    \For{$i = 2$\ \textbf{to}\ $\infty$}
    \While {$Goal \in \abs{\mathcal{V}}$}
    \State Let $t = \Call{Reconstruct}{\abs{R}, Init, Goal}$
    \If {$\eval{t} = Goal$}
    \State \Return $t$
    \EndIf
    \State Let $\hat{\sigma} \in \abs{V_j}$ be a splittable state s.t.
    $path_{\abs{R}}(Goal, \sigma)$ and $\hat{\sigma} = \hat{\sigma_l} \sqcup
    \hat{\sigma_r}$ where $\hat{\sigma_l} \sqcap \hat{\sigma_r} = \emptyset$.
    \State $\abs{\mathcal{V}} <- \abs{\mathcal{V}} \setminus \bigcup_{k > j} \abs{V_k}$
    \State $\abs{V_j} <- (\abs{V_j} \setminus \hat{\sigma}) \cup
    \{\hat{\sigma_l}, \hat{\sigma_r}\}$
    \For{$k = j + 1$\ \textbf{to}\ $i - 1$}
    \State $\abs{V_k}, \abs{R} <- \Call{Fill}{O, \abs{\mathcal{V}}, k}$
    \EndFor
    \EndWhile
    \State $\abs{V_i}, \abs{R} <- \Call{Fill}{O, \abs{\mathcal{V}}, i}$
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

This algorithm is straightforwardly sound because it only returns programs that
reach the goal state.
\begin{theorem}[Abstract Soundness]
  If $\Call{AbstractBottomUp}{O, Init, Goal} = t$, then $\eval{t} = Goal$.
\end{theorem}
\begin{proof}
  $\Call{AbstractBottomUp}{O, Init, Goal}$ returns a program $t$ iff $\eval{t} = Goal$.
\end{proof}

To prove that the abstract algorithm is complete we show that if a program is
found by the concrete bottom-up algorithm, then an equivalent program will also
be found by the abstract bottom-up algorithm.

\begin{theorem}[Abstract Completeness]
  If $\Call{BottomUp}{O, Init, Goal} = t$, then $\Call{AbstractBottomUp}{O,
    Init, Goal} = t'$ where $\eval{t} = \eval{t'} = Goal$.
\end{theorem}

Assume that we have run \textsc{BottomUp} and generated a program $t$ and state
sets $\mathcal{V}$. We show that as \textsc{AbstractBottomUp} runs, its abstract
state sets $\abs{\mathcal{V}}$ converge to $\mathcal{V}$.

First we show that that each abstract state set $\abs{V_i}$ is a partition of
the corresponding concrete state set $V_i$ at all points during the execution of
\textsc{AbstractBottomUp}. Two concrete states $\sigma, \sigma'$ are in the same
partition if there exists an abstract state $\abs{\delta}$ such that $\sigma,
\sigma' \in \abs{\delta}$. Informally, $\abs{V_i}$ must partition $V_i$ because
(1) the initial $\abs{V_0} = \emptyset$ and $\abs{V_1} = \{\top\}$ are
partitions and (2) the update step on line 11 replaces a state $\hat{\sigma}$
with two disjoint states $\hat{\sigma_l}$ and $\hat{\sigma_r}$, so $\abs{V_j}$
remains a partition.

Because the $\abs{V_i}$ are partitions, they form a lattice ordered by the
finer-than relation. The least element of the lattice is $V_i$ and the greatest
element is $\{\top\}$.

\begin{definition}[Finer-than]
  $\abs{\mathcal{V}} \leq \abs{\mathcal{V}}'$ if every element of
  $\abs{\mathcal{V}}$ is a subset of some element of $\abs{\mathcal{V}}'$.
\end{definition}

Now we can extend the ordering on $\abs{V_i}$ to an ordering on
$\abs{\mathcal{V}}$. Ordering the sets $\abs{V_0}, \dots, \abs{V_k}$
lexicographically gives us a partial order on $\abs{\mathcal{V}}$ where the
least element is $\mathcal{V}$.

Now we show that $\abs{\mathcal{V}}$ decreases in each iteration of the outer
loop in \textsc{AbstractBottomUp}. If $Goal \in \abs{\mathcal{V}}$ then we
select a state and split it into two disjoint states. We then remove all of the
state sets that can contain states that depend on the split state. If
$\abs{\mathcal{V}}$ and $\abs{\mathcal{V}}'$ are the state sets before and after
splitting, then $\abs{\mathcal{V}}' < \abs{\mathcal{V}}$. The set $\abs{V_j}$
that contains the split state strictly decreases according to the refinement
order after replacing the split state with two smaller states. Therefore, the
$\abs{\mathcal{V}}$ strictly decreases as well.

Let $\abs{\mathcal{V}}''$ be the state sets after the filling step on lines
12-14. This step only changes $V_k$ where $k > j$, so $\abs{\mathcal{V}}'' \leq
\abs{\mathcal{V}}'$. The same argument holds for the filling step on line 16.

We can conclude that $\abs{\mathcal{V}}$ strictly decreases for every iteration
of the outer loop. Since $\mathcal{V}$ is the least element in this ordering,
eventually $\abs{\mathcal{V}} = \mathcal{V}$, at which point
\textsc{AbstractBottomUp} will terminate with a program $t$, because
\textsc{BottomUp} also terminated with a program $t$.

Note that \textsc{AbstractBottomUp} can terminate before converging if a correct
program is found.


\section{Implementation}
\subsection{Data Structures}

The search space is structured as a graph with two kinds of nodes: state nodes
and operator nodes. State nodes are approximations of reachable program states.
Operator nodes represent the operators of the DSL and act as hyperedges that
connect multiple input states to a single output state. Program inputs are
treated as no-argument operators.

State nodes are labeled with an abstract value representing a set of concrete
program states and an integer cost. The cost is the number of AST nodes in the
programs that can reach the state. States in the graph are hash-consed, and
including costs in the state nodes ensures that the search graph is acyclic.

Operator nodes are labeled with an operator.

Edges in the graph are labeled with integers. If the edge is from a state node
to an operator node, then the edge label determines the position of the input in
the operator's argument list. Edges from operator nodes to state nodes have a
dummy label.

The search space graph respects the following invariants:
\begin{itemize}
\item State nodes are preceded by at least one operator node.
\item An operator node $v_o$ is preceded by $\texttt{arity}(v_o)$ state nodes.
\item Operator nodes are succeeded by at least one state node.
\end{itemize}

\subsection{Search}

The search proceeds in two phases: filling and refinement. The filling step
extends the graph by inserting new operator nodes. The refinement step splits
state nodes to recover from errors caused by over-abstraction.

The synthesizer fills the graph until a state containing the expected output is
reached. At this point there are two possibilities: either the output is truly
reachable, in which case a program can be extracted from the search graph, or it
is not reachable and only appears to be because of over-approximation. The
\texttt{Refine} function determines which of these possibilities is true and
either returns a refined search space or terminates the program with a solution.

\begin{algorithm}
  \begin{algorithmic}
    \Function{Fixup}{$G = (V, E)$}
    \Repeat
    \State $V \gets V \setminus \{v\}$ for $v \in V_{state}$ if $\not \exists v'
    \in V_{op}.\ (v', v) \in E$
    \State $V \gets V \setminus \{v\}$ for $v \in V_{op}$ if $|\{v' \in
    V_{state}.\ (v', v) \in E\}| \neq
    \texttt{arity}(v)$
    \Until {fixpoint}
    \State \Return $G$
    \EndFunction
    \State
    \Function{Refine}{$G = (V, E), s_{out}, out$}
    \State Let $G' = (V', E')$ be the subset of $G$ that can reach $s_{out}$
    \ForAll {$S \subseteq V'$ s.t. $S$ only contains operator nodes and $S$ is a
      separator of $G'$}
    \State Let $x_{v, b}$ be boolean variables corresponding to each bit $b$ in
    each node $v \in V'$.
    \State Let $e_{v, v'}$ be boolean variables corresponding to each edge $(v,
    v') \in E'$.
    \State Let $\Phi_{out} = \bigwedge_j x_{s_{out}, j} = out_j$
    \State Let $\Phi_{semantics} = \bigwedge_{v \in V'_{op} \ S} x_{v} =
    \texttt{op}(v)(A_v)$ where $A_v = \{v' ~|~ v' \in V'_{state}, (v', v) \in E' \}$
    \State Let $\Psi_{semantics} = \bigwedge_{v \in S} x_{v} =
    \texttt{op}(v)(A_v)$ where $A_v = \{v' ~|~ v' \in V'_{state}, (v', v) \in E \}$
    \If {$\Phi_{out} \land \Phi_{semantics} \land \Psi_{semantics}$ is
      satisfiable}
    \State Use the selected edges $e$ to extract a program.
    \Else
    \State Let $I$ be an interpolant between $\Psi$ and $\Phi$.
    \State Let $V_{refined} = \{(v, b) | v \in V_{op}, \exists b. x_{v, b} \in
    \texttt{vars}(I)\}$
    \ForAll {$(v, b) \in V_{refined}$}
    \State Let $succ = \{v' | v' \in V\}$
    \State Let $pos = \{(v, v' \sqcup \{b \mapsto \top \}) | v' \in succ \}$
    \State Let $neg = \{(v, v' \sqcup \{b \mapsto \bot \}) | v' \in succ \}$
    \State $E \gets E \setminus {(v, v') | v' \in succ}$
    \If {$I \models x_{v, b}$}
    \State $E \gets E \cup pos$
    \ElsIf {$I \models \lnot x_{v, b}$}
    \State $E \gets E \cup neg$
    \Else
    \State $E \gets E \cup pos \cup neg$
    \EndIf
    \EndFor

    \State \Call{Fixup}{$G$}
    \State \Return $G$
    \EndIf
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\texttt{Refine} first selects the subset of the search graph that can reach the
node that contains the expected output. Only this subset of the graph is
relevant and pruning here reduces the size of the constraint problem that we
will generate.

Next, we generate a constraint problem that asks if we can generate a program
that produces the correct output by selecting edges in the reduced graph. When
generating the constraint, we select a graph separator that partitions the graph
into a top half and a bottom half. If the constraint problem is unsatisfiable,
we will receive an interpolant in terms of the variables that label the edges
that are cut by this separator.

If the constraint is satisfiable, we can use the selected edges to extract a
working program and return it.

Otherwise, we get an interpolant. We select the argument nodes whose output
variables participate in the interpolant. These nodes are the source of the
imprecision that caused the output to be spuriously reachable.

Although we can safely refine all of the variables mentioned in the interpolant,
we prune the refinement by first checking whether the interpolant entails any of
its variables. If so, those variables can be assigned rather than split.

To refine the search graph, we iterate through the operator nodes that
participate in the interpolant and prune their outgoing edges. We replace their
output nodes with one fresh output node if their corresponding bit is entailed.
Otherwise, they get two fresh output nodes with the appropriate bits refined.

After this update step, we fix up the search graph by removing state nodes with
no inputs and operator nodes without the correct number of inputs.

% \begin{algorithm}
%   \begin{algorithmic}
%     \Function{Synth}{$I, O$}
%     \State Let $G = (I \cup \{\top\}, \bigcup_{in \in I} (in, \top))$
%     \Loop
%     \State $G \gets \Call{Fill}{G}$
%     \If {$\exists s \in V$ s.t. $O \sqsubseteq
%       \texttt{state}(s)$}
%     \State $G \gets \Call{Refine}{G, s}$
%     \EndIf
%     \EndLoop
%     \EndFunction
%   \end{algorithmic}
% \end{algorithm}

% \begin{algorithm}
%   \begin{algorithmic}
%     \Function{Fill}{$G=(V, E)$}
%     \State Choose an operator $op$ and states $s_1, \dots,
%     s_{\texttt{arity}(op)}$ such that the edges $E' = \bigcup_i (s_i, op)$ do not exist in
%     the graph and $\sum_i \texttt{cost}(s_i)$ is minimized.
%     \State \Return $(V \cup {op}, E \cup E')$
%     \EndFunction
%   \end{algorithmic}
% \end{algorithm}


\end{document}

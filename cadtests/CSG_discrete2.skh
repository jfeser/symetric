pragma options "--fe-fpencoding TO_BACKEND --bnd-unroll-amnt 32 --bnd-inline-amnt 4";

include "math.skh";
#define DEPTH 4

adt CuboidHint {
	float theta_x;
	float theta_y;
	float theta_z;
	int xlen;
	int ylen;
	int zlen;
	float[xlen] xlist;
	int[xlen] xlistint;
	float[ylen] ylist;
	int[ylen] ylistint;
	float[zlen] zlist;
	int[zlen] zlistint;
}

adt CylinderHint {
	float theta_x;
	float theta_y;
	float theta_z;
	float radius;
	float y;
	float z;
	int xlen;
	float[xlen] xlist;
	int[xlen] xlistint;
}



adt Vector {
  float x;
  float y;
  float z;
}



bit renderSphere(Vector p, float x, float y, float z, float r) {
	print("Sphere(Vector("); printfloat(x); print(","); printfloat(y); print(","); printfloat(z); print("),"); printfloat(r*r); print(")");
	return (p.x - x)*(p.x - x) + (p.y - y)*(p.y - y) + (p.z - z)*(p.z - z) - r*r <= 0.0;
}

// First rotate along z axis with -thetaz, then along y-axis with -thetay, finally along x-axis with -thetax
Vector inverse_rotate(Vector p, float theta_x, float theta_y, float theta_z) {
	float x0 = p.x; float y0 = p.y; float z0 = p.z;
	
	float x1 = cos(-theta_z)*x0 - sin(-theta_z)*y0;
	float y1 = sin(-theta_z)*x0 + cos(-theta_z)*y0;
	float z1 = z0;
	
	float x2 = cos(-theta_y)*x1 + sin(-theta_y)*z1;
	float y2 = y1;
	float z2 = -sin(-theta_y)*x1 + cos(-theta_y)*z1;
	
	float x3 = x2;
	float y3 = cos(-theta_x)*y2 -sin(-theta_x)*z2;
	float z3 = sin(-theta_x)*y2 + cos(-theta_x)*z2;

	return new Vector(x = x3, y = y3, z = z3);	
}

generator float getOffset([int n], float[n] offsets) {
	int idx = ??;
	return offsets[idx];
}

generator bit getCuboid(Vector p, int id) {
	CuboidHint c = cuboidHints[id];
	assert(c != null);
	Vector p_rotated = inverse_rotate(p, c.theta_x, c.theta_y, c.theta_z);
	
	float xl = getOffset(c.xlist);
	float yl = getOffset(c.ylist);
	float zl = getOffset(c.zlist);
	
	float xu = getOffset(c.xlist);
	float yu = getOffset(c.ylist);
	float zu = getOffset(c.zlist);
	
	assert(xl < xu);
	assert(yl < yu);
	assert(zl < zu);
	print("Cuboid("); printInt(id); print(",Vector("); printfloat(c.theta_x); print(","); printfloat(c.theta_y); print(","); printfloat(c.theta_z);
	print("),Vector("); printfloat(xl); print(","); printfloat(yl); print(","); printfloat(zl); 
	print("),Vector("); printfloat(xu - xl); print(","); printfloat(yu - yl); print(","); printfloat(zu - zl); print("))");
	
	bit x_in_range = p_rotated.x >= xl && p_rotated.x <= xu;
    bit y_in_range = p_rotated.y >= yl && p_rotated.y <= yu;
    bit z_in_range = p_rotated.z >= zl && p_rotated.z <= zu;
    return x_in_range && y_in_range && z_in_range;
}

generator bit getCylinder(Vector p, int id) {
	CylinderHint c = cylinderHints[id];
	assert(c != null);
	
	Vector p_rotated = inverse_rotate(p, c.theta_x, c.theta_y, c.theta_z);
	float xl = getOffset(c.xlist);
	float xu = getOffset(c.xlist);
	assert(xl < xu);
	print("Cylinder("); printInt(id); print(",Vector("); printfloat(c.theta_x); print(","); printfloat(c.theta_y); print(","); printfloat(c.theta_z);
	print("),Vector("); printfloat(xl); print(","); printfloat(c.y); print(","); printfloat(c.z); print("),");
	print("Vector("); printfloat(xu - xl); print(",0,0),");
	printfloat(c.radius); print(")");
	
	bit withinRadius = (p_rotated.y - c.y) * (p_rotated.y - c.y) + (p_rotated.z - c.z) * (p_rotated.z - c.z) - c.radius*c.radius <= 0.0;
	bit withinHeight = p_rotated.x >= xl && p_rotated.x <= xu;
	return withinRadius && withinHeight;
}


//TODO: Add rankings: put unions before intersections, etc.
generator bit sample_expression(Vector p, int d){ 
	if (d <= 1) {
		if (!??) {
			return getSphere(p);
		}
		
		int i = 0;
		repeat(numCylinderHints) {
			if (!??) {
				return getCylinder(p, i);
			}
			i += 1;
		}
		i = 0;
		repeat(numCuboidHints) {
			if (!??) {
				return getCuboid(p, i);
			}
			i += 1;
		}
		assert(false); 
	} else {
		bit b1 = !??; 
		bit b2 = !??;
		if (b1) {
			print("Union(");
		} else if (b2) {
			print("Intersection(");
		} else {
			print("Subtract(");
		}
		bit expression1 = false;
		bit expression2 = false;
		expression1 = sample_expression(p, d - 1);
		print(",");
		expression2 = sample_expression(p, d - 1);
		print(")");
	  if (b1) {
		  return expression1 || expression2;
	  }
	  else if (b2) { 
		  return expression1 && expression2;
	  }
	  else {
		  return expression1 && !expression2;
	  }
	} 
	
	
}


bit contains(Vector p) {
	return sample_expression(p, DEPTH);
}


void checkAll() {
	for (int i = 0; i < NUM_DATA; i++){
		Vector v = new Vector(x = xs[i], y = ys[i], z = zs[i]);
		if (labels[i]) {
			assert contains(v);
		} else {
			assert !contains(v);
		}
	}
}

@Native("{ std::cout << message; }")
void print([int n], char[n] message){}

@Native("{ std::cout << n; }")
void printfloat(float n){}

@Native("{ std::cout << i; }")
void printInt(int i){}

    

* DONE Add sexp loading to synth.ml
  CLOSED: [2020-01-23 Thu 19:03]
** DONE Remove EXAMPLES signature from LANG
   CLOSED: [2020-01-16 Thu 16:29]
** DONE Use genlet to generate example input binding
   CLOSED: [2020-01-21 Tue 18:28]
** DONE Add sexp parser interface for values
   CLOSED: [2020-01-16 Thu 16:29]
** DONE Make synth aware of inputs
   CLOSED: [2020-01-21 Tue 18:49]

* DONE Figure out why reconstruction isn't happening
  CLOSED: [2020-01-22 Wed 19:40]

* CANCELED Figure out how to make Deepcoder.Value fit in with the other code values
  CLOSED: [2020-01-20 Mon 17:45]
  - too hard for now
  - there are two basic options since the value type is not really a code value
    - either the code type needs to be extensible so that value can be slotted in later
    - unfortunately, value doesn't always act like a code

* DONE Benchmark generation
  CLOSED: [2020-01-27 Mon 18:05]
** DONE Random term generation from grammar
   CLOSED: [2020-01-23 Thu 19:03]
   - just do this in a dumb way. the smart way is too much of a pain
** DONE Random value generator
   CLOSED: [2020-01-23 Thu 19:03]
* TODO Tests for ocaml implementation of staged 
* TODO Need a better way to handle partial operations in DSLs
* DONE Profile output of deepcoder dsl
  CLOSED: [2020-01-27 Mon 18:04]
  Found that the dominant costs are for vector copying & allocation:
  15.71%  a.out    a.out              [.] std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<int>
  11.53%  a.out    a.out              [.] std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<
   9.11%  a.out    a.out              [.] std::vector<int, std::allocator<int> >::vector
   5.90%  a.out    a.out              [.] std::operator< <int, std::allocator<int> >
   5.43%  a.out    a.out              [.] std::vector<int, std::allocator<int> >::operator[]
   5.04%  a.out    a.out              [.] std::_Vector_base<int, std::allocator<int> >::~_Vector_base
* DONE Thread cache into reconstruction functions using arguments
  CLOSED: [2020-01-28 Tue 16:05]
* TODO Implement of_code, code_of interface for VALUE
* TODO Implement fixed size arrays for deepcoder
** TODO Fix bugs in this implementation
* TODO Fix buggy interactions between genlet and with_stackmark
** TODO Pull with_stackmark into let or fresh_var or something
* DONE Benchmark plots for deepcoder
  CLOSED: [2020-01-29 Wed 18:25]
* TODO Comparison/equality functions for standard types
* DONE Different collection implementations should be incompatible at the type level
  CLOSED: [2020-01-30 Thu 15:13]
* DONE Add phantom type to type witnesses
  CLOSED: [2020-01-30 Thu 16:07]
* TODO Talk to kevin about his linguistics domain and figure out why it was so hard to reduce to sketch
* CANCELED Load a context at synthesizer start instead of putting values into the table directly
  CLOSED: [2020-04-16 Thu 18:30]
* CANCELED Type safe n-ary tuples
  CLOSED: [2020-04-16 Thu 18:30]
* DONE 3-tuples
  CLOSED: [2020-04-16 Thu 18:30]
* DONE Floats
  CLOSED: [2020-04-16 Thu 18:30]
* TODO Implement CAD dsl
** DONE Implement 3 and 4 tuples
   CLOSED: [2020-04-15 Wed 18:58]
** DONE Implement floating point
   CLOSED: [2020-04-15 Wed 18:58]
** DONE Implement cylinders
   CLOSED: [2020-04-22 Wed 20:02]
*** DONE Implement argument predicates
    CLOSED: [2020-04-19 Sun 18:45]
*** DONE Figure out how to handle array indexes
    CLOSED: [2020-04-19 Sun 18:45]
** DONE Implement cuboids
   CLOSED: [2020-04-27 Mon 13:46]
** DONE Encode cad dsl examples
   CLOSED: [2020-04-23 Thu 16:00]
** TODO Encode more cad dsl examples
* DONE Implement predicates that use binders
  CLOSED: [2020-04-22 Wed 20:02]
  - for a rule we currently generate a loop nest with one loop for each distinct
    nonterminal in the rule
    - if a nonterminal appears more than once we duplicate the evaluation code
      for each permutation
** DONE Switch to generating one loop per nonterminal
   CLOSED: [2020-04-21 Tue 20:27]
* DONE Fix implementation of fill 
  CLOSED: [2020-04-22 Wed 14:39]
  - there's a mismatch between the args that get passed to binding_ctx and the
    args that we check for dependencies on
* TODO Add test for cad dsl with sphere index predicate
* TODO Write each fill code snippet for a state as a partial order and use partial order merging to create a fused loop nest
* DONE Restructure input data as relations to avoid array indexing
  CLOSED: [2020-04-22 Wed 20:01]
* TODO Fix arena arrays if we're going to use them
* TODO Implement custom cost functions
* The cad benchmarks need deductive reasoning
  - or maybe not? note that we can't use deduction to push through union/inter compositions
** TODO Add a way to attach a predicate to a state so we can control what values end up in that state's pool
* DONE Implement lazy cegis prototype
  CLOSED: [2020-06-29 Mon 13:40]
** DONE Implement child refinement
   CLOSED: [2020-06-02 Tue 18:54]
   - iterate over the possible example additions, prioritizing the additions
     that have a low index until an addition is found that makes the abstract
     state no longer contain the bad concrete output
** DONE Implement the main loop
   CLOSED: [2020-06-08 Mon 19:16]
*** DONE Implement checking for output in abstract states
    CLOSED: [2020-06-08 Mon 19:16]
*** DONE Implement program extraction
    CLOSED: [2020-06-08 Mon 13:46]
*** DONE Implement strengthening using child refinement and program extraction
    CLOSED: [2020-06-08 Mon 13:46]
*** DONE Implement pruning (needs node marking)
    CLOSED: [2020-06-08 Mon 19:16]
*** DONE Use fill to implement expansion of graph
    CLOSED: [2020-06-08 Mon 19:16]
*** DONE Implement node marking
    CLOSED: [2020-06-08 Mon 19:16]
** DONE Refine_children is doing the wrong thing. it should refine the input abstract states so that they evaluate to the expected abstract output, while respecting the concrete execution
   CLOSED: [2020-06-16 Tue 18:47]
* DONE Finish modifying lazy cegis algorithm
  CLOSED: [2020-06-16 Tue 18:46]
  - a single state node can be reached by multiple args nodes, representing the
    application of different operators
  - when a state is refined, all of the args need to be refined
* DONE Fix up stats for changes in graph
  CLOSED: [2020-06-17 Wed 18:02]
* DONE Add random refinement
  CLOSED: [2020-06-17 Wed 18:02]
* DONE Add pareto refinement
  CLOSED: [2020-06-29 Mon 13:39]
* CANCELED Try with structured bitvectors
  CLOSED: [2020-07-01 Wed 19:02]
* TODO Write a benchmark generator
* TODO Extend language with repeat construct
* DONE Generate a repeat benchmark with spheres
  CLOSED: [2020-07-01 Wed 19:02]
* CANCELED Extend sphere benchmark to be trace complete
  CLOSED: [2020-07-06 Mon 19:43]
* TODO Rework filling to handle new operators
* TODO Refinement needs to be done per-operator?
* TODO Prototype of interpolation based refinement
** DONE Pruning is broken 
   CLOSED: [2020-07-30 Thu 20:26]

** DONE How to handle cycles in the state graph?
   CLOSED: [2020-07-31 Fri 18:51]
   - could forbid cycles
     - is it sound to ignore operations that produce a state that is already in the graph?
     - what about operations that produce a state that is in the graph but is
       cheaper than the state that the operation should have produced?
   - can also eliminate cycles by representing each state at each cost
     - we don't generally care about the higher cost versions of a state
** DONE Use sat solver to handle interpolants instead of parsing them
   CLOSED: [2020-08-13 Thu 20:30]
** DONE Pruning is broken again
   CLOSED: [2020-08-14 Fri 19:22]
** TODO Investigate incremental filling
** TODO Fix refinements
   Separators where some nodes in the separator depend on the output of others
   don't give correct refinements: the refinements don't respect the concrete
   semantics
*** DONE Visualize the edges selected by the interpolant
    CLOSED: [2020-08-17 Mon 19:10]
*** DONE Refinements need to introduce node splits
    CLOSED: [2020-08-19 Wed 10:51]
*** DONE State vars are ignored in refinements
    CLOSED: [2020-08-19 Wed 11:57]
*** DONE Fix bit normalization Some/None
    CLOSED: [2020-08-21 Fri 17:14]

* TODO Improve performance
** DONE Replace in_cone with a traversal of the cone
   CLOSED: [2020-08-25 Tue 15:32]
** DONE Don't repeat work when generating smt
   CLOSED: [2020-08-26 Wed 18:44]
** CANCELED Switch to multi-arg representation
   CLOSED: [2020-09-29 Tue 20:58]
** TODO Reimplement cost cache
* TODO Translate cad benchmarks for performance eval
* TODO Writeup
** TODO BottomUp should return a program, since AbstractBottomUp needs the program structure to talk about refinements
** TODO Implement AbstractBottomUp in terms of an abstract refinement procedure that either splits a state into a disjoint union or removes a state
** TODO Prove that with this simple refinement model, the abstract algorithm is correct
    Key ideas:
    - When we hit a goal state, nondeterministically split a state or remove an unreachable state

When refining, we nondeterministically select a state that participates in the
spurious program. We then prune every state at a higher level (because they are
the only ones that could have been derived from the bad state). Since states
can't be refined indefinitely, eventually all of the first level states will be
fully refined and once that happens the algorithm reverts to concrete bottom up.

Might have to refine a state set instead of a single state. We know that this
set always exists because either all of the reconstructed programs are correct
or there exists an incorrect program that can be split out.

After refinement and filling, abs(V') comes before abs(V) in the refinement
level partial order. Splitting a state in V_i generates V_i' and V_i' < V_i.

Each abs(V_i) is a partition of V_i, and different abs(V_i)s are ordered by the
finer-than relation. abs(V) is a sequence of these abs(V_i)s and these sequences
are ordered lexicographically using the finer than order. Therefore, as the
abstract search runs, its V state descends in the partial order. We know that
there are no infinite descending chains in this order, so eventually it has to
hit the concrete V.
